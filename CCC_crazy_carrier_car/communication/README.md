# 各种工具函数和串口函数

## 概述
- 比较混乱，主要是串口接收发送和定时器终端的一些处理函数，目前还没有解耦，所以还掺杂着一些功能函数在里面，后续慢慢优化
- usart1 用于和电机通信 
- usart2 用于和串口屏通信
- usart3 用于和树莓派通信


## 使用

串口屏通信和树莓派通信的相关函数在`my_usart.c`和`my_usart.h`中，定时器中断的处理函数在`my_timer.c`和`my_timer.h`中


**电机闭环控制思路（目前废弃）**
首先开一个定时器定时读取电机的实时转速，然后再开一个定时器，根据实际转速和目标转速进行PID控制


**定时器中串口通信思路**
思路：
目前全部的通信大致分为以下三种：
1. 串口屏通信。最简单，只需要发送数据，不需要接收数据，可以在main函数中进行
2. 电机控制通信。目前只传输数据给电机，在中断里发送数据即可
3. 树莓派通信。较为复杂，需要在到位后给树莓派发出识别的信号，也需要解析树莓派发出信号，且对响应的实时性和准确度要求很高

**定时器中电机控制思路**
思路：
在给定路线的移动中，可以直接在main的大循环里HAL_Delay。但在根据视觉进行微调的过程中，只能慢慢微调，此时在main中进行则不方便，需在定时器中进行。

但由于旧有的电机驱动要发五条指令，且指令间需要延迟，故如果直接在定时器里调用原先的控制函数，则会出现HAL_Delay,这会造成中断的卡死，所以驱动函数不能这么写。得设定几个计时的变量，然后根据定时器的中断来进行计时，从而达到既做到延迟，又不用HAL_Delay的目的。

实现：
要重新写电机的移动函数，当开始小幅度移动时，改变标志位（表明电机开始移动，且给出移动的时间），然后在定时器中进行计时，等延时达到了10ms则发送一条电机驱动指令，相当于把原先电机移动中的HAL_Delay用定时器的计时实现延时。等到指令都发送了，电机开始运动，继续在定时器中进行计时，等电机运动到了指定的位置，改变标志位（表明电机转动完成，可以接受下一次的指令了）

## 已完成
- 串口屏通信和返回数据的初步处理
- 树莓派的通信和返回数据的初步处理
- 树莓派数据通信与简单的位置控制
- 用定时器实现电机的控制和串口通信（即各种数据的传输在定时器中进行，包括电机驱动的控制）


## 未完成
- 串口改用DMA方式接收数据，提高效率（较为复杂）
- 串口屏和树莓派返回数据的处理优化（加入更多的校验位以确保数据的准确性，规定好数据包的结构，还可以考虑加入多种校验）